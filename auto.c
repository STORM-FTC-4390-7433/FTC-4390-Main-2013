#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  none)
#pragma config(Hubs,  S2, HTMotor,  none,     none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     IRSensor,       sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C2_1,     frontLeft,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     frontRight,    tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     ladderMotor,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     flagMotor,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_1,     backLeft,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     backRight,     tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C1_1,    rakeServo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C1_2,    pendulumMoverServo,   tServoStandard)
#pragma config(Servo,  srvo_S1_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define COMPETITION

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "drive.h"
#include "drive.c"
#include "ladder.h"
#include "ladder.c"
#include "flag.h"
#include "flag.c"
#include "rake.h"
#include "rake.c"
#include "drivers/hitechnic-irseeker-v2.h"

DriveSys drive;
LadderSys ladder;
FlagSys flag;
RakeSys rake;

void initializeRobot()
{
	drive.backLeft = backLeft;
    drive.backRight = backRight;
    drive.frontLeft = frontLeft;
    drive.frontRight = frontRight;

    ladder.ladderMotor = ladderMotor;

    flag.flagMotor = flagMotor;

    rake.rakeServo = rakeServo;
    rake.maxValue = 210;
    rake.minValue = 120;

    rake.pendulumMoverServo = pendulumMoverServo;

	servo[rake.rakeServo] = 135;
	servo[rake.pendulumMoverServo] = 0;

	return;
}

int maxSig(int num0, int num1, int num2, int num3, int num4){
    if(num0>num1 && num0>num2 && num0>num3 && num0>num4) return num0;
    if(num1>num2 && num1>num3 && num1>num4) return num1;
    if(num2>num3 && num2>num4) return num2;
    if(num3>num4) return num3;
    return num4;
}

void driveEncoders(int inches){
	int startValue = nMotorEncoder[frontRight];
	int endValue = startValue + (inches * 90);

	if((endValue-startValue)<0){
		while(nMotorEncoder[frontRight]>=endValue){
			motor[frontRight]=-25;
			motor[frontLeft]=-25;
			motor[backRight]=-25;
			motor[backLeft]=-25;
		}
	} else if((endValue-startValue)>0){
		while(nMotorEncoder[frontRight]<=endValue){
			motor[frontRight]=25;
			motor[frontLeft]=25;
			motor[backRight]=25;
			motor[backLeft]=25;
		}
	}

	//writeDebugStreamLine("The encoder value is: %d End value %d", nMotorEncoder[frontRight], endValue);

	motor[frontRight]=0;
	motor[frontLeft]=0;
	motor[backRight]=0;
	motor[backLeft]=0;
}

void turn(float fAngle){
	//positive turns right, negative turns left
	int startValue = nMotorEncoder[frontRight];
	int endValue = startValue + (1575 * (fAngle/90));

	//turn left
	while(nMotorEncoder[frontRight]<=endValue){
		motor[frontRight]=50;
		motor[frontLeft]=-50;
		motor[backRight]=50;
		motor[backLeft]=-50;
	}

	//turn right
	while(nMotorEncoder[frontRight]>=endValue){
		motor[frontRight]=-50;
		motor[frontLeft]=50;
		motor[backRight]=-50;
		motor[backLeft]=50;
	}

	motor[frontRight]=0;
	motor[frontLeft]=0;
	motor[backRight]=0;
	motor[backLeft]=0;
}

void turnRight(){
	int startValue = nMotorEncoder[frontRight];
	int endValue = startValue - 1575;

	while(nMotorEncoder[frontRight]>=endValue){
		motor[frontRight]=-50;
		motor[frontLeft]=50;
		motor[backRight]=-50;
		motor[backLeft]=50;
	}

	motor[frontRight]=0;
	motor[frontLeft]=0;
	motor[backRight]=0;
	motor[backLeft]=0;
}

void turnLeft(){
	int startValue = nMotorEncoder[frontRight];
	int endValue = startValue + 1575; // turned 90 degrees 12/12/13

	while(nMotorEncoder[frontRight]<=endValue){
		motor[frontRight]=50;
		motor[frontLeft]=-50;
		motor[backRight]=50;
		motor[backLeft]=-50;
	}

	motor[frontRight]=0;
	motor[frontLeft]=0;
	motor[backRight]=0;
	motor[backLeft]=0;
}

void driveToBasket(){
	driveEncoders(30);
	turnLeft();
}

void depositBlock(){
	driveEncoders(5);
}

void driveToRamp(){
	turnRight();
	driveEncoders(-30);
	turnLeft();
	driveEncoders(20);
	turnRight();
	driveEncoders(30);
}


task main(){

	initializeRobot();

	#ifdef COMPETITION
	waitForStart();   // wait for start of tele-op phase
	#endif

	nMotorEncoder[frontRight]=0;

	//Debugging code
	PlaySound(soundBeepBeep);
	driveEncoders(20);
	turnLeft();
	turnRight();
	driveEncoders(-20);
	PlaySound(soundBeepBeep);

	//Encoder method
	/*
	driveToBasket();
	depositBlock();
	drivetoRamp();
	*/

	//Detect IR Beacon method (Read Direction)
	/*
    if(HTIRS2readDCDir(IRSensor)==5){

	}
	*/

    //Detect IR Beacon method (Read All)
	/*
	int irs[5]; //infra-red sensor strengths, maximmum signal
    HTIRS2readAllACStrength(IRSensor, irs[0], irs[1], irs[2], irs[3], irs[4]);
    while(maxSig(irs[0], irs[1], irs[2], irs[3], irs[4])!=irs[0]){
		//while IR Sensor is not detected
		//drive forward
		updateDriveSys(drive, 100, 100, 100, 100);
	}
	*/

    //Drive backwards onto ramp method
	/*
    updateDriveSys(drive, -100, -100, -100, -100);
    wait1Msec(3000);
	*/
}
